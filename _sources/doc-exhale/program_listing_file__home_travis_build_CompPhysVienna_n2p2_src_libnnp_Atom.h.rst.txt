
.. _program_listing_file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Atom.h:

Program Listing for File Atom.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Atom.h>` (``/home/travis/build/CompPhysVienna/n2p2/src/libnnp/Atom.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // n2p2 - A neural network potential package
   // Copyright (C) 2018 Andreas Singraber (University of Vienna)
   //
   // This program is free software: you can redistribute it and/or modify
   // it under the terms of the GNU General Public License as published by
   // the Free Software Foundation, either version 3 of the License, or
   // (at your option) any later version.
   //
   // This program is distributed in the hope that it will be useful,
   // but WITHOUT ANY WARRANTY; without even the implied warranty of
   // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   // GNU General Public License for more details.
   //
   // You should have received a copy of the GNU General Public License
   // along with this program.  If not, see <https://www.gnu.org/licenses/>.
   
   #ifndef ATOM_H
   #define ATOM_H
   
   #include "CutoffFunction.h"
   #include "Vec3D.h"
   #include <cstddef> // std::size_t
   #include <string>  // std::string
   #include <vector>  // std::vector
   
   namespace nnp
   {
   
   struct Atom
   {
       struct Neighbor
       {
           std::size_t                index;
           std::size_t                tag;
           std::size_t                element;
           double                     d;
           double                     fc;
           double                     dfc;
           double                     rc;
           double                     cutoffAlpha;
           CutoffFunction::CutoffType cutoffType;
           Vec3D                      dr;
           std::vector<Vec3D>         dGdr;
   
           Neighbor();
           bool                     operator==(Neighbor const& rhs) const;
           bool                     operator!=(Neighbor const& rhs) const;
           bool                     operator<(Neighbor const& rhs) const;
           bool                     operator>(Neighbor const& rhs) const;
           bool                     operator<=(Neighbor const& rhs) const;
           bool                     operator>=(Neighbor const& rhs) const;
           std::vector<std::string> info() const;
       };
   
       bool                     hasNeighborList;
       bool                     hasSymmetryFunctions;
       bool                     hasSymmetryFunctionDerivatives;
       std::size_t              index;
       std::size_t              indexStructure;
       std::size_t              tag;
       std::size_t              element;
       std::size_t              numNeighbors;
       std::size_t              numNeighborsUnique;
       std::size_t              numSymmetryFunctions;
       double                   energy;
       double                   charge;
       Vec3D                    r;
       Vec3D                    f;
       Vec3D                    fRef;
       std::vector<std::size_t> neighborsUnique;
       std::vector<std::size_t> numNeighborsPerElement;
       std::vector<std::size_t> numSymmetryFunctionDerivatives;
       std::vector<double>      G;
       std::vector<double>      dEdG;
   #ifndef IMPROVED_SFD_MEMORY
       std::vector<double>      dGdxia;
   #endif
       std::vector<Vec3D>       dGdr;
       std::vector<Neighbor>    neighbors;
   
       Atom();
   #ifndef IMPROVED_SFD_MEMORY
   
       void                     collectDGdxia(std::size_t indexAtom,
                                              std::size_t indexComponent);
   #endif
   
       void                     toNormalizedUnits(double convEnergy,
                                                  double convLength);
       void                     toPhysicalUnits(double convEnergy,
                                                double convLength);
       void                     allocate(bool all);
       void                     free(bool all);
       void                     clearNeighborList();
       void                     clearNeighborList(std::size_t const numElements);
       std::size_t              getNumNeighbors(double cutoffRadius) const;
       void                     updateRmseForces(double&      rmse,
                                                 std::size_t& count) const;
       std::vector<std::string> getForcesLines() const;
       std::vector<std::string> info() const;
   };
   
   inline bool Atom::Neighbor::operator!=(Atom::Neighbor const& rhs) const
   {
       return !((*this) == rhs);
   }
   
   inline bool Atom::Neighbor::operator>(Atom::Neighbor const& rhs) const
   {
       return rhs < (*this);
   }
   
   inline bool Atom::Neighbor::operator<=(Atom::Neighbor const& rhs) const
   {
       return !((*this) > rhs);
   }
   
   inline bool Atom::Neighbor::operator>=(Atom::Neighbor const& rhs) const
   {
       return !((*this) < rhs);
   }
   
   }
   
   #endif
