
.. _program_listing_file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Vec3D.h:

Program Listing for File Vec3D.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_CompPhysVienna_n2p2_src_libnnp_Vec3D.h>` (``/home/travis/build/CompPhysVienna/n2p2/src/libnnp/Vec3D.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // n2p2 - A neural network potential package
   // Copyright (C) 2018 Andreas Singraber (University of Vienna)
   //
   // This program is free software: you can redistribute it and/or modify
   // it under the terms of the GNU General Public License as published by
   // the Free Software Foundation, either version 3 of the License, or
   // (at your option) any later version.
   //
   // This program is distributed in the hope that it will be useful,
   // but WITHOUT ANY WARRANTY; without even the implied warranty of
   // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   // GNU General Public License for more details.
   //
   // You should have received a copy of the GNU General Public License
   // along with this program.  If not, see <https://www.gnu.org/licenses/>.
   
   #ifndef VEC3D_H
   #define VEC3D_H
   
   #include <cstddef>   // std::size_t
   #include <cmath>     // sqrt
   #include <stdexcept> // std::runtime_error
   
   namespace nnp
   {
   
   struct Vec3D
   {
       double r[3];
   
       Vec3D();
       Vec3D(double x, double y, double z);
       Vec3D(Vec3D const& source);
       Vec3D&        operator=(Vec3D const& rhs);
       Vec3D&        operator+=(Vec3D const& v);
       Vec3D&        operator-=(Vec3D const& v);
       Vec3D&        operator*=(double const a);
       Vec3D&        operator/=(double const a);
       double        operator*(Vec3D const& v) const;
       double&       operator[](std::size_t const index);
       double const& operator[](std::size_t const index) const;
       bool          operator==(Vec3D const& rhs) const;
       bool          operator!=(Vec3D const& rhs) const;
       double        norm() const;
       double        norm2() const;
       Vec3D&        normalize();
       Vec3D         cross(Vec3D const& v) const;
   };
   
   Vec3D operator+(Vec3D lhs, Vec3D const& rhs);
   Vec3D operator-(Vec3D lhs, Vec3D const& rhs);
   Vec3D operator-(Vec3D v);
   Vec3D operator*(Vec3D v, double const a);
   Vec3D operator/(Vec3D v, double const a);
   Vec3D operator*(double const a, Vec3D v);
   
   // Inlined function definitions //
   
   inline Vec3D::Vec3D()
   {
       r[0] = 0.0;
       r[1] = 0.0;
       r[2] = 0.0;
   }
   
   inline Vec3D::Vec3D(double x, double y, double z)
   {
       r[0] = x;
       r[1] = y;
       r[2] = z;
   }
   
   inline Vec3D::Vec3D(Vec3D const& source)
   {
       r[0] = source.r[0];
       r[1] = source.r[1];
       r[2] = source.r[2];
   }
   
   inline Vec3D& Vec3D::operator=(Vec3D const& rhs)
   {
       r[0] = rhs.r[0];
       r[1] = rhs.r[1];
       r[2] = rhs.r[2];
   
       return *this;
   }
   
   inline Vec3D& Vec3D::operator+=(Vec3D const& rhs)
   {
       r[0] += rhs.r[0];
       r[1] += rhs.r[1];
       r[2] += rhs.r[2];
   
       return *this;
   }
   
   inline Vec3D& Vec3D::operator-=(Vec3D const& rhs)
   {
       r[0] -= rhs.r[0];
       r[1] -= rhs.r[1];
       r[2] -= rhs.r[2];
   
       return *this;
   }
   
   inline Vec3D& Vec3D::operator*=(double const a)
   {
       r[0] *= a;
       r[1] *= a;
       r[2] *= a;
   
       return *this;
   }
   
   inline Vec3D& Vec3D::operator/=(double const a)
   {
       *this *= 1.0 / a;
   
       return *this;
   }
   
   inline double Vec3D::operator*(Vec3D const& v) const
   {
       return r[0] * v.r[0] + r[1] * v.r[1] + r[2] * v.r[2];
   }
   
   // Doxygen requires namespace prefix for arguments...
   inline double& Vec3D::operator[](std::size_t const index)
   {
       if (index < 3) return r[index];
       else
       {
           throw std::runtime_error("ERROR: 3D vector has only three"
                                    " components.\n");
       }
   }
   
   // Doxygen requires namespace prefix for arguments...
   inline double const& Vec3D::operator[](std::size_t const index) const
   {
       if (index < 3) return r[index];
       else
       {
           throw std::runtime_error("ERROR: 3D vector has only three"
                                    " components.\n");
       }
   }
   
   inline bool Vec3D::operator==(Vec3D const& rhs) const
   {
       if (r[0] != rhs.r[0]) return false;
       if (r[1] != rhs.r[1]) return false;
       if (r[2] != rhs.r[2]) return false;
       return true;
   }
   
   inline bool Vec3D::operator!=(Vec3D const& rhs) const
   {
       return !(*this == rhs);
   }
   
   inline double Vec3D::norm() const
   {
       return sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
   }
   
   inline double Vec3D::norm2() const
   {
       return r[0] * r[0] + r[1] * r[1] + r[2] * r[2];
   }
   
   inline Vec3D& Vec3D::normalize()
   {
       double n = norm();
       r[0] /= n;
       r[1] /= n;
       r[2] /= n;
   
       return *this;
   }
   
   inline Vec3D Vec3D::cross(Vec3D const& v) const
   {
       Vec3D w;
   
       w.r[0] = r[1] * v.r[2] - r[2] * v.r[1];
       w.r[1] = r[2] * v.r[0] - r[0] * v.r[2];
       w.r[2] = r[0] * v.r[1] - r[1] * v.r[0];
   
       return w;
   }
   
   inline Vec3D operator+(Vec3D lhs, Vec3D const& rhs)
   {
       return lhs += rhs;
   }
   
   inline Vec3D operator-(Vec3D lhs, Vec3D const& rhs)
   {
       return lhs -= rhs;
   }
   
   inline Vec3D operator-(Vec3D v)
   {
       v *= -1.0;
       return v;
   }
   
   inline Vec3D operator*(Vec3D v, double const a)
   {
       return v *= a;
   }
   
   inline Vec3D operator/(Vec3D v, double const a)
   {
       return v /= a;
   }
   
   inline Vec3D operator*(double const a, Vec3D v)
   {
       return v *= a;
   }
   
   }
   
   #endif
